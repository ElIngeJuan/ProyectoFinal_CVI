#include "Structures.fxh"

#ifndef DXCOMPILER
#    define NonUniformResourceIndex(x) x
#endif

Texture2D    g_Textures[NUM_TEXTURES];
SamplerState g_Samplers[NUM_SAMPLERS];
TextureCube  g_ReflectionMap;
SamplerState g_ReflectionSampler;

ConstantBuffer<GlobalConstants>   g_Constants;
StructuredBuffer<MaterialAttribs> g_MaterialAttribs;

struct PSInput
{
    float4 Pos  : SV_POSITION;
    float4 WPos : WORLD_POS;
    float3 Norm : NORMAL;
    float2 UV   : TEX_COORD;
    nointerpolation uint MatId : MATERIAL;
};

struct PSOutput
{
    float4 Color : SV_Target0;
    float4 Norm  : SV_Target1;
};

void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
    MaterialAttribs material = g_MaterialAttribs[PSIn.MatId];
    
    if (PSIn.MatId == g_Constants.WaterMaterialId)
    {
        // Calcular normales
        float3 N = normalize(PSIn.Norm);
        
        // Aplicar normal map si existe
        if (material.NormalMapTexInd >= 0)
        {
            float3 normalMap = g_Textures[NonUniformResourceIndex(material.NormalMapTexInd)]
                .Sample(g_Samplers[NonUniformResourceIndex(material.SampInd)], PSIn.UV).rgb;
            
            // Construir TBN
            float3 tangent = normalize(cross(N, float3(0, 0, 1)));
            float3 bitangent = cross(N, tangent);
            float3x3 TBN = float3x3(tangent, bitangent, N);
            
            N = normalize(mul(normalMap * 2.0 - 1.0, TBN));
        }

        // Calcular reflejos
        float3 viewDir = normalize(g_Constants.CameraPos.xyz - PSIn.WPos.xyz);
        float3 reflectDir = reflect(-viewDir, N);
        float4 reflectionColor = g_ReflectionMap.Sample(g_ReflectionSampler, reflectDir);


        // Término Fresnel
        float fresnel = pow(saturate(1.0 - dot(N, viewDir)), material.FresnelPower);
        fresnel = lerp(0.04, 1.0, fresnel);

        // Mezclar color base con reflejo
        float3 baseColor = material.BaseColorMask.rgb;
        float3 finalColor = lerp(baseColor, reflectionColor.rgb, fresnel * material.Reflectivity);

        PSOut.Color = float4(finalColor, material.Transparency);
        PSOut.Norm = float4(N * 0.5 + 0.5, material.Reflectivity);
    }
    else
    {
        // Materiales regulares
        float4 baseColor = material.BaseColorMask;
        if (material.BaseColorTexInd >= 0)
        {
            baseColor *= g_Textures[NonUniformResourceIndex(material.BaseColorTexInd)]
                .Sample(g_Samplers[NonUniformResourceIndex(material.SampInd)], PSIn.UV);
        }

        PSOut.Color = baseColor;
        PSOut.Norm = float4(normalize(PSIn.Norm) * 0.5 + 0.5, 0.0);
    }
}